Runni ng the  fi na l tra di ng e c o s y s te m
We are finally at the point where we can run our entire electronic trading ecosystem, admittedly with a
random trading strategy for now. We will present two scripts – one is
Chapter10/scripts/run_clients.sh, which is configured to launch five instances of the
trading_main application with client IDs of 1 to 5. The second script is
Chapter10/scripts/run_exchange_and_clients.sh, which first builds the libraries and the binaries
using the build.sh script. Then, it launches the exchange_main application and proceeds to launch the
trading client instances using the run_clients.sh script. Finally, it waits for all the trading client
instances to finish execution, then terminates the exchange instance, and exits.
We will not look at the full run_clients.sh script, but an example of the first trading client that creates
a MarketMaker algorithm is shown here:
 
./cmake-build-release/trading_main  1 MAKER 100 0.6 150 300 -100 60 0.6 150 300 -100 
150 0.5 250 600 -100 200 0.4 500 3000 -100 1000 0.9 5000 4000 -100 300 0.8 1500 3000 
-100 50 0.7 150 300 -100 100 0.3 250 300 -100 &
In this script, the 1 and 2 client IDs are MM trading algorithms, the 3 and 4 client IDs are liquidity taking
trading algorithms, and the last client ID, 5, is a random trading algorithm. The random trading algorithm
instance exists to simulate all trades made by the rest of the market participants for any reason. We do
this because, in our ecosystem, we only run five trading clients (due to limited resources on our
workstation). However, we encourage those interested among you with access to a lot more CPU
resources to run as many trading clients as the system can handle. Remember that, in practice, the
market is composed of orders and trades from thousands of market participants (if not more).
First, we have the output of the build process, which is generated by running the
scripts/run_exchange_and_clients.sh script that internally calls the scripts/build.sh script to first
build everything. Note that you need to be in the Chapter10 root directory, as shown here, for this script
to work correctly:
 
sghosh@sghosh-ThinkPad-X1-Carbon-3rd:~/Building-Low-Latency-Applications-with-
CPP/Chapter10$ bash scripts/run_exchange_and_clients.sh 
... 
-- Build files have been written to: /home/sghosh/Building-Low-Latency-Applications-
with-CPP/Chapter10/cmake-build-release 
... 
[36/37] Linking CXX executable trading_main 
[37/37] Linking CXX executable exchange_main
Then, we have the output of the exchange_main application starting up:
 
----------------------------------------- 
Starting Exchange... 
----------------------------------------- 
Set core affinity for Common/Logger exchange_main.log 140716464399936 to -1 
Set core affinity for Common/Logger exchange_matching_engine.log 140716293985856 to 
-1 
...
Then, the output of the trading_main instances launching is produced:
 
----------------------------------------- 
Starting TradingClient 1... 
----------------------------------------- 
Set core affinity for Common/Logger trading_main_1.log 139636947019328 to -1 
... 
----------------------------------------- 
Starting TradingClient 5... 
----------------------------------------- 
Set core affinity for Common/Logger trading_main_5.log 139837285852736 to -1 
...
Finally, we have the output from the trading clients that shut down, and then the exchange exits:
 
Set core affinity for Trading/MarketDataConsumer 139836325348928 to –1 
... 
Thu Apr  6 12:37:04 2023 Flushing and closing Logger for trading_main_1.log 
... 
Thu Apr  6 12:37:21 2023 Logger for trading_order_gateway_5.log exiting. 
----------------------------------------- 
Stopping Exchange... 
----------------------------------------- 
... 
Thu Apr  6 12:38:09 2023 Logger for exchange_order_server.log exiting.
Note that this is just the output displayed on screen. The interesting details are in the log files, which we
will inspect and discuss in the next subsection.
One other important note is that the exchange_main application has 10 threads, and each trading_main
application has 8 threads. The Logger threads, which are many of these threads (five for
exchange_main and four for trading_main), as well as the thread for the main() method (one each for
exchange_main and trading_main), are not CPU-intensive and sleep for most of their runtime. The
optimal setup would need a lot of cores for the entire ecosystem, which is common for production
trading servers used for electronic trading. On these production-grade trading servers, we would be able
to assign a CPU core to each of the remaining critical threads (four for exchange_main and three for
trading_main). Since we are not sure which server we run on, we intentionally avoid setting affinity on
those threads. If CPU and/or memory resources are limited on your system, our advice would be to
reduce the number of trading clients launched in the run_clients.sh script.
Ins pe c ti ng the  o utput o f a  run
In this concluding section, we will look at the log files generated by running the
run_exchange_and_clients.sh script. We know that the trading strategy we ran in this chapter is not
interesting since it sends random orders to the exchange, but there are some important observations in
these log files. Running the run_exchange_and_clients.sh script should generate log files similar to
the following:
 
exchange_main.log  exchange_market_data_publisher.log  exchange_matching_engine.log  
exchange_order_server.log  exchange_snapshot_synthesizer.log 
trading_engine_1.log  trading_main_1.log  trading_market_data_consumer_1.log  trading
_order_gateway_1.log 
... trading_order_gateway_5.log
To understand and follow the events, our advice would be to correlate the log lines we generate from
our calls to Logger::log() from various components and sub-components and then find them in the log
files.
As an example, let us follow the path of a client sending an order to the exchange receiving the request,
and generating a client response and a market update for that order request. Let us say, for this
example, that we want to find the path followed by OrderId=1445 and MarketOrderId=53; the path
which this order follows is laid out as follows from the log files. Note that this is just an example that
was generated from this specific run and might not be reproducible; the goal here is to understand how
to track the events in our ecosystem:
1. MEClientRequest for the new order gets sent by the TradeEngine component for the trading_main instance with
ClientId=1:
 
trading_engine_5.log:trade_engine.cpp:33 sendClientRequest() Thu Apr  6 12:26:47 
2023 Sending MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 
price:184]
2. The OrderGateway component picks up that request from the lock-free queue and sends it out on the TCP connection to
the exchange, as shown here:
 
trading_order_gateway_5.log:order_gateway.cpp:19 run() Thu Apr  6 12:26:47 2023 
Sending cid:1 seq:891 MEClientRequest [type:NEW client:1 ticker:0 oid:1445 
side:BUY qty:10 price:184]
3. The OrderServer component inside the exchange_main application receives it from the TCPServer socket, as
shown here:
 
exchange_order_server.log:order_server.h:55 recvCallback() Thu Apr  6 12:26:47 
2023 Received OMClientRequest [seq:891 MEClientRequest [type:NEW client:1 
ticker:0 oid:1445 side:BUY qty:10 price:184]]
4. The FifoSequencer sub-component inside OrderServer sequences the client order request (MEClientRequest)
based on the software receive time, and publishes it to the MatchingEngine lock-free queue:
 
exchange_order_server.log:fifo_sequencer.h:38 sequenceAndPublish() Thu Apr  6 
12:26:47 2023 Writing RX:1680802007777361000 Req:MEClientRequest [type:NEW 
client:1 ticker:0 oid:1445 side:BUY qty:10 price:184] to FIFO.
5. The MatchingEngine component finally receives this request from LFQueue and processes it, as displayed in the
following log file:
 
exchange_matching_engine.log:matching_engine.h:66 run() Thu Apr  6 12:26:47 2023 
Processing MEClientRequest [type:NEW client:1 ticker:0 oid:1445 side:BUY qty:10 
price:184]
6. In response to the order request it received, the MatchingEngine component generates a MEClientResponse message
meant for the client to be published by the OrderServer component:
 
exchange_matching_engine.log:matching_engine.h:48 sendClientResponse() Thu Apr  6 
12:26:47 2023 Sending MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 
moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]
7. Corresponding to the new order that is added to the limit order book, MatchingEngine also generates an
MEMarketUpdate message, as shown here. This is meant for the MarketDataPublisher component to publish and
update the snapshot it maintains:
 
exchange_matching_engine.log:matching_engine.h:55 sendMarketUpdate() Thu Apr  6 
12:26:47 2023 Sending MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 
price:184 priority:2]
8. The OrderServer component picks up the MEClientResponse message from LFQueue, sending out an
OMClientResponse message to the client on the correct TCP connection with the trading client:
 
exchange_order_server.log:order_server.h:32 run() Thu Apr  6 12:26:47 2023 
Processing cid:1 seq:1343 MEClientResponse [type:ACCEPTED client:1 ticker:0 
coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]
9. The MarketDataPublisher component picks up the MEMarketUpdate message sent by MatchingEngine, sending
out an MDPMarketUpdate message on the incremental market data multicast stream:
 
exchange_market_data_publisher.log:market_data_publisher.cpp:19 run() Thu Apr  6 
12:26:47 2023 Sending seq:902 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY 
qty:10 price:184 priority:2]
10. The SnapshotSynthesizer sub-component inside the MarketDataPublisher component also receives this
incremental MEMarketUpdate message, adding it to the snapshot it maintains:
 
exchange_snapshot_synthesizer.log:snapshot_synthesizer.cpp:107 run() Thu Apr  6 
12:26:47 2023 Processing MDPMarketUpdate [ seq:902 MEMarketUpdate [ type:ADD 
ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]]
11. At some point, SnapshotSynthesizer publishes a snapshot of the MDPMarketUpdate messages on the snapshot
multicast market data stream, including this market update:
 
exchange_snapshot_synthesizer.log:snapshot_synthesizer.cpp:88 publishSnapshot() 
Thu Apr  6 12:27:40 2023 MDPMarketUpdate [ seq:7 MEMarketUpdate [ type:ADD 
ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]]
12. The OrderGateway component inside the trading_main application receives the OMClientResponse response for
the order request, from the TCPSocket that is connected to the exchange:
 
trading_order_gateway_5.log:order_gateway.cpp:37 recvCallback() Thu Apr  6 
12:26:47 2023 Received OMClientResponse [seq:1343 MEClientResponse [type:ACCEPTED 
client:1 ticker:0 coid:1445 moid:53 side:BUY exec_qty:0 leaves_qty:10 price:184]]
13. The MarketDataConsumer component inside the trading_main application receives the MDPMarketUpdate
message on the incremental market data stream:
 
trading_market_data_consumer_5.log:market_data_consumer.cpp:177 recvCallback() 
Thu Apr  6 12:26:47 2023 Received incremental socket len:42 MDPMarketUpdate [ 
seq:902 MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 
priority:2]]
 
trading_market_data_consumer_5.log:market_data_consumer.cpp:193 recvCallback() 
Thu Apr  6 12:26:47 2023 MDPMarketUpdate [ seq:902 MEMarketUpdate [ type:ADD 
ticker:0 oid:53 side:BUY qty:10 price:184 priority:2]]
14. The TradeEngine component finally receives the MEClientResponse message from the OrderGateway component
over the lock-free queue. It also forwards the MEClientResponse message via the onOrderUpdate() callback:
 
trading_engine_5.log:trade_engine.cpp:44 run() Thu Apr  6 12:26:47 2023 
Processing MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 
side:BUY exec_qty:0 leaves_qty:10 price:184]
 
trading_engine_5.log:trade_engine.cpp:75 onOrderUpdate() Thu Apr  6 12:26:47 2023 
MEClientResponse [type:ACCEPTED client:1 ticker:0 coid:1445 moid:53 side:BUY 
exec_qty:0 leaves_qty:10 price:184]
15. TradeEngine also receives the MEMarketUpdate message, updates MarketOrderBook, and, in turn, receives
onOrderBookUpdate() from the order book back in TradeEngine:
 
trading_engine_5.log:trade_engine.cpp:52 run() Thu Apr  6 12:26:47 2023 
Processing MEMarketUpdate [ type:ADD ticker:0 oid:53 side:BUY qty:10 price:184 
priority:2]
 
trading_engine_5.log:trade_engine.cpp:64 onOrderBookUpdate() Thu Apr  6 12:26:47 
2023 ticker:0 price:184 side:BUY
Hopefully, this example provided you with good insight into what the different components in our trading
ecosystem do. This should also serve as an example of how to investigate different events in the various
applications, components, and sub-components of our electronic trading universe.
Now, let us focus on the entries generated by our other components – FeatureEngine, RiskManager,
PositionKeeper, and OrderManager – and the strategies – the MarketMaker and LiquidityTaker
algorithms:
1. The following log lines display the feature values that are updated by FeatureEngine as the order book updates or new
trade events occur in market data:
 
trading_engine_1.log:feature_engine.h:23 onOrderBookUpdate() Thu May 11 16:10:45 
2023 ticker:7 price:152 side:BUY mkt-price:152.394 agg-trade-ratio:0.0994475
 
trading_engine_1.log:feature_engine.h:34 onTradeUpdate() Thu May 11 16:10:45 2023 
MEMarketUpdate [ type:TRADE ticker:1 oid:INVALID side:SELL qty:50 price:170 
priority:INVALID] mkt-price:170.071 agg-trade-ratio:1
 
trading_engine_1.log:feature_engine.h:23 onOrderBookUpdate() Thu May 11 16:10:45 
2023 ticker:2 price:119 side:SELL mkt-price:115.299 agg-trade-ratio:0.262712
 
trading_engine_1.log:feature_engine.h:34 onTradeUpdate() Thu May 11 16:10:45 2023 
MEMarketUpdate [ type:TRADE ticker:3 oid:INVALID side:BUY qty:18 price:180 
priority:INVALID] mkt-price:115.299 agg-trade-ratio:0.00628931
 
trading_engine_1.log:feature_engine.h:23 onOrderBookUpdate() Thu May 11 16:10:45 
2023 ticker:3 price:180 side:SELL mkt-price:178.716 agg-trade-ratio:0.00628931
 
trading_engine_1.log:feature_engine.h:34 onTradeUpdate() Thu May 11 16:10:45 2023 
MEMarketUpdate [ type:TRADE ticker:3 oid:INVALID side:BUY qty:30 price:180 
priority:INVALID] mkt-price:178.716 agg-trade-ratio:0.0105485
2. The following log lines correspond to PositionKeeper being updated as BBO changes or additional executions are
processed:
 
trading_engine_1.log:position_keeper.h:75 addFill() Thu May 11 16:10:38 2023 
Position{pos:476 u-pnl:-120.715 r-pnl:6248.71 t-pnl:6128 vol:8654 vwaps:
[114.254X0] BBO{21@115X116@296}} MEClientResponse [type:FILLED client:1 ticker:2 
coid:962 moid:1384 side:BUY exec_qty:25 leaves_qty:102 price:114]
 
trading_engine_1.log:position_keeper.h:98 updateBBO() Thu May 11 16:10:42 2023 
Position{pos:194 u-pnl:15.8965 r-pnl:311.103 t-pnl:327 vol:802 vwaps:[180.918X0] 
BBO{730@180X182@100}} BBO{730@180X182@100}
 
trading_engine_1.log:position_keeper.h:75 addFill() Thu May 11 16:10:42 2023 
Position{pos:392 u-pnl:688.98 r-pnl:6435.02 t-pnl:7124 vol:8782 vwaps:[114.242X0] 
BBO{44@114X116@150}} MEClientResponse [type:FILLED client:1 ticker:2 coid:970 
moid:1394 side:SELL exec_qty:83 leaves_qty:44 price:116]
 
trading_engine_1.log:position_keeper.h:98 updateBBO() Thu May 11 16:10:44 2023 
Position{pos:373 u-pnl:282.585 r-pnl:6468.41 t-pnl:6751 vol:8801 vwaps:
[114.242X0] BBO{19@114X116@131}} BBO{19@114X116@131}
3. Failures in RiskManager, due to several reasons we discussed in the Building the C++ trading algorithm building blocks
chapter in the Computing and managing risk section, show up in the log files as something like the following:
 
trading_engine_1.log:order_manager.h:69 moveOrder() Thu May 11 16:10:41 2023 
Ticker:1 Side:BUY Qty:60 RiskCheckResult:POSITION_TOO_LARGE
 
trading_engine_1.log:order_manager.h:69 moveOrder() Thu May 11 16:10:41 2023 
Ticker:4 Side:SELL Qty:1000 RiskCheckResult:LOSS_TOO_LARGE
 
trading_engine_1.log:order_manager.h:69 moveOrder() Thu May 11 16:10:42 2023 
Ticker:2 Side:BUY Qty:150 RiskCheckResult:POSITION_TOO_LARGE
4. Events in OrderManager appear as follows in the log files, as attempts are made to send order requests and responses are
processed:
 
trading_engine_1.log:order_manager.h:26 onOrderUpdate() Thu May 11 16:10:36 2023 
OMOrder[tid:6 oid:965 side:SELL price:125 qty:15 state:PENDING_CANCEL]
 
trading_engine_1.log:order_manager.cpp:13 newOrder() Thu May 11 16:10:37 2023 
Sent new order MEClientRequest [type:NEW client:1 ticker:6 oid:966 side:SELL 
qty:50 price:126] for OMOrder[tid:6 oid:966 side:SELL price:126 qty:50 
state:PENDING_NEW]
 
trading_engine_1.log:order_manager.h:23 onOrderUpdate() Thu May 11 16:10:37 2023 
MEClientResponse [type:ACCEPTED client:1 ticker:6 coid:966 moid:1806 side:SELL 
exec_qty:0 leaves_qty:50 price:126]
 
trading_engine_1.log:order_manager.h:26 onOrderUpdate() Thu May 11 16:10:37 2023 
OMOrder[tid:6 oid:966 side:SELL price:126 qty:50 state:PENDING_NEW]
 
trading_engine_1.log:order_manager.cpp:26 cancelOrder() Thu May 11 16:10:37 2023 
Sent cancel MEClientRequest [type:CANCEL client:1 ticker:1 oid:927 side:SELL 
qty:60 price:170] for OMOrder[tid:1 oid:927 side:SELL price:170 qty:60 
state:PENDING_CANCEL]
 
trading_engine_1.log:order_manager.h:23 onOrderUpdate() Thu May 11 16:10:37 2023 
MEClientResponse [type:CANCELED client:1 ticker:1 coid:927 moid:1826 side:SELL 
exec_qty:INVALID leaves_qty:60 price:170]
5. Events in the LiquidityTaker trading strategy appear as shown here. These correspond to order book updates, trade
events, and updates to strategy orders:
 
trading_engine_1.log:liquidity_taker.h:19 onOrderBookUpdate() Thu May 11 16:07:48 
2023 ticker:4 price:183 side:SELL
 
trading_engine_1.log:liquidity_taker.h:19 onOrderBookUpdate() Thu May 11 16:07:48 
2023 ticker:7 price:153 side:BUY
 
trading_engine_1.log:liquidity_taker.h:25 onTradeUpdate() Thu May 11 16:07:48 
2023 MEMarketUpdate [ type:TRADE ticker:7 oid:INVALID side:SELL qty:90 price:154 
priority:INVALID]
 
trading_engine_1.log:liquidity_taker.h:32 onTradeUpdate() Thu May 11 16:07:48 
2023 BBO{368@154X155@2095} agg-qty-ratio:0.244565
 
trading_engine_1.log:liquidity_taker.h:19 onOrderBookUpdate() Thu May 11 16:07:48 
2023 ticker:7 price:154 side:BUY
 
trading_engine_1.log:liquidity_taker.h:49 onOrderUpdate() Thu May 11 16:07:48 
2023 MEClientResponse [type:FILLED client:3 ticker:7 coid:202 moid:792 side:BUY 
exec_qty:90 leaves_qty:183 price:154]
 
trading_engine_1.log:liquidity_taker.h:19 onOrderBookUpdate() Thu May 11 16:07:48 
2023 ticker:0 price:180 side:BUY
6. Similarly, events in the MarketMaker trading algorithm appear in the log files, as shown here:
 
trading_engine_1.log:market_maker.h:47 onOrderUpdate() Thu May 11 16:06:12 2023 
MEClientResponse [type:FILLED client:1 ticker:5 coid:418 moid:552 side:BUY 
exec_qty:62 leaves_qty:160 price:137]
 
trading_engine_1.log:market_maker.h:42 onTradeUpdate() Thu May 11 16:06:12 2023 
MEMarketUpdate [ type:TRADE ticker:3 oid:INVALID side:BUY qty:47 price:180 
priority:INVALID]
 
trading_engine_1.log:market_maker.h:19 onOrderBookUpdate() Thu May 11 16:06:12 
2023 ticker:3 price:180 side:SELL
 
trading_engine_1.log:market_maker.h:27 onOrderBookUpdate() Thu May 11 16:06:12 
2023 BBO{2759@178X180@2409} fair-price:179.068
 
trading_engine_1.log:market_maker.h:19 onOrderBookUpdate() Thu May 11 16:06:12 
2023 ticker:0 price:183 side:SELL
 
trading_engine_1.log:market_maker.h:27 onOrderBookUpdate() Thu May 11 16:06:12 
2023 BBO{4395@181X182@534} fair-price:181.892
 
trading_engine_1.log:market_maker.h:42 onTradeUpdate() Thu May 11 16:06:12 2023 
MEMarketUpdate [ type:TRADE ticker:5 oid:INVALID side:SELL qty:62 price:137 
priority:INVALID]
 
trading_engine_1.log:market_maker.h:19 onOrderBookUpdate() Thu May 11 16:06:12 
2023 ticker:5 price:137 side:BUY
We encourage you to inspect the various log files in more detail to understand the processing that occurs
in the different components and how our entire electronic trading ecosystem functions.
